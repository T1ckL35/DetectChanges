name: config
on:
  push:
  workflow_dispatch:
    inputs:
      logLevel:
        description: 'Log level'
        required: true
        default: 'warning'
        type: choice
        options:
        - info
        - warning
        - debug

jobs:
  build_configuration:
    name: Build Configuration
    runs-on: ubuntu-latest
    # To add in at some point
    # if: github.event.pull_request.merged == true
    # Map a step output to a job output. A shortcut way to defining a variable instead of the full path
    #     e.g, 
    #outputs:
    #  matrix: ${{ steps.run_script.outputs.MODULES_MATRIX }}    # Will be used in another job to run module tests with
    outputs:
        all_changed_files: ${{ steps.build_changed_files.outputs.changed_files }}                 # diff of all current files that have changed. ALso used to build a configuration on if a module has tests to run
        modules_configuration: ${{ steps.build_tests_matrix_includes.outputs.MODULES_CONFIG }}    # configuration of module information for any that have had file changes made. Consists of the module name and a list of tests, if present. Future additions will be to detect the current module version and predict the next version to use if all tests pass
        tests_matrix: ${{ steps.build_tests_matrix_includes.outputs.TESTS_MATRIX_OUTPUT }}        # matrix of tests to run against changed modules
    steps:
      - id: checkout-codebase
        name: Checks out the codebase as needed. If this is a PR then it uses a fetch-depth of 2 to determine the changes. Otherwise the fetch-depth is 0 to get the full git history
        uses: actions/checkout@v4
        with:
          # Note, if a depth of 2 is used then we will need to checkout again with a depth of zero in a later step so that GitVersion has the full repo history to be able to create a semver version with..
          fetch-depth: ${{ github.event_name == 'pull_request' && 2 || 0 }}

      - id: build_changed_files
        name: Builds a list of changed modules and their files. Output to 'changed_files' variable
        run: |
          # Pushes output to $GITHUB_OUTPUT so it can be used in other jobs/steps
          if ${{ github.event_name == 'pull_request' }}; then
              echo "changed_files=$(git diff --name-only -r HEAD^1 HEAD | xargs)" >> $GITHUB_OUTPUT
          else
              echo "changed_files=$(git diff --name-only ${{ github.event.before }} ${{ github.event.after }} | xargs)" >> $GITHUB_OUTPUT
          fi

      - id: determine_versions
        name: Optional at present. Only needed if we want to determine the next module version to tag. This part can work with GitVersion but may need changing as that is not in the allowed Github Actions for NBS as yet (even though it is used in the cicd github actions catalog)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - id: setup_python
        name: Set up Python to use
        uses: actions/setup-python@v5
        with:
          python-version: 3.12
          # cache: 'pip' # caching pip dependencies
      - id: install_dependencies
        name: Install dependencies
        run: |
          # Install the dependencies
          python -m pip install --upgrade pip
          pip install -r requirements.txt
      - id: configure_pythonpath
        name: Sorts the PYTHONPATH so we can import custom python modules from the codebase
        run: |
          echo "PYTHONPATH=$PYTHONPATH:${{ github.workspace }}" >> $GITHUB_ENV
      - id: show_pythonPath
        name: show python path
        run: |
          python -c "import sys; import os; print('\n'.join(sys.path)); print(os.getcwd())"
      - id: build_tests_matrix_includes
        name: Run a python script inline to convert a bash space deparated string into a json list
        shell: python
        run: |
          # codepath isn't in PYTHONPATH
          # ${{ github.workspace }} # e.g, /home/runner/work/my-repo-name/my-repo-name
          from scripts import modules_config

          # Create an instance of the ModulesConfig class
          app = modules_config.ModulesConfig()

          ## Example of how to prepopulate modules_config for if it has already been set or needs to be overridden
          ## test_modules_config_override = '[{"module": "module3", "tests": ["bdd"]}]'
          ## app = modules_config.ModulesConfig(test_modules_config_override)

          # Configure logging to output to both file and console. TODO: only do this if running the workflow in debug mode
          app.output_logging()
          
          # Build the modules config
          # Automatically pushes the modules configuration to GITHUB_OUTPUT so it can be used in other jobs/steps
          app.build_modules_config("${{ steps.build_changed_files.outputs.changed_files }}", "MODULES_CONFIG")
          
          # Build the tests include matrix config. Automatically pushes the result to GITHUB_OUTPUT
          app.build_tests_matrix_config()
      - id: debug_show_modules_config
        name: Check the modules config output is correct
        run: |
          echo "${{ steps.build_tests_matrix_includes.outputs.MODULES_CONFIG }}"
          echo "${{ steps.build_tests_matrix_includes.outputs.TESTS_MATRIX_OUTPUT }}"
      - id: testing_pygithub
        name: Testing PyGithub
        run: |
          python -c "import os; from github import Github; g = Github(os.environ['GITHUB_TOKEN']); print(g.get_user())"


  run_module_tests:
    name: "Run Module Tests: ${{matrix.module}} - ${{matrix.test}}"
    needs: [build_configuration]
    if: ${{ success() && needs.build_configuration.outputs.tests_matrix }}
    runs-on: ubuntu-latest
    strategy:
      matrix: ${{ fromJSON(needs.build_configuration.outputs.tests_matrix) }}
        # tests_matrix is a prebuilt json structure that maps to something similar as below in yaml
        # An example json structure is: {"include":[{"module":"module1","test":"unit"},{"module":"module1","test":"bdd"},{"module":"module2","test":"unit"}]}
        # And the corresponding conversion to yaml with the fromJSON github function is below:
        # The include configuration makes this job run multiple times for each item and passes in the matrix values for each.
        # So in this case 3 jobs are run: [module1, unit], [module, 1 bdd] and [module2, unit]
        # include:
        #   - module: "module1"
        #     test: "unit"
        #   - module: "module1"
        #     test: "bdd"
        #   - module: "module2"
        #     test: "unit"
    steps:
      - id: run_test
        name: "Run ${{matrix.test}} tests on ${{matrix.module}}"
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      # debug
      - run: |
          echo "For Module: ${{matrix.module}} Running Test: ${{matrix.test}}"  
      # debug
      - run: |
          echo "Debug on modules_configuration variable: ${{ needs.build_configuration.outputs.modules_configuration }}"


  # test_update_modules_config:
  #   name: Testing updating the modules_config
  #   needs: [run_module_tests]
  #   runs-on: ubuntu-latest
